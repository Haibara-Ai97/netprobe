package ebpf

import (
	"log"
	"time"
)

package ebpf

import (
	"fmt"
	"log"
	"net"
	"time"
)

// SecurityEventHandler ÂÆâÂÖ®‰∫ã‰ª∂Â§ÑÁêÜÂô®
type SecurityEventHandler struct {
	alertCallback    func(event *NetworkEvent)
	anomalyThreshold int
	anomalyCount     map[uint32]int // IP -> count
	lastCleanup      time.Time
}

// NewSecurityEventHandler ÂàõÂª∫ÂÆâÂÖ®‰∫ã‰ª∂Â§ÑÁêÜÂô®
func NewSecurityEventHandler() *SecurityEventHandler {
	return &SecurityEventHandler{
		anomalyThreshold: 10, // 10Ê¨°ÂºÇÂ∏∏ÂêéËß¶ÂèëÂëäË≠¶
		anomalyCount:     make(map[uint32]int),
		lastCleanup:      time.Now(),
	}
}

// SetAlertCallback ËÆæÁΩÆÂëäË≠¶ÂõûË∞ÉÂáΩÊï∞
func (seh *SecurityEventHandler) SetAlertCallback(callback func(event *NetworkEvent)) {
	seh.alertCallback = callback
}

// HandleEvent Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
func (seh *SecurityEventHandler) HandleEvent(event *NetworkEvent) error {
	switch event.EventType {
	case EventTypeSecurity:
		seh.handleSecurityEvent(event)
	case EventTypeDDoS:
		seh.handleDDoSEvent(event)
	case EventTypeAnomaly:
		seh.handleAnomalyEvent(event)
	}
	
	// ÂÆöÊúüÊ∏ÖÁêÜËÆ°Êï∞Âô®
	if time.Since(seh.lastCleanup) > 5*time.Minute {
		seh.cleanupCounters()
		seh.lastCleanup = time.Now()
	}
	
	return nil
}

// HandleBatch Â§ÑÁêÜÊâπÈáè‰∫ã‰ª∂
func (seh *SecurityEventHandler) HandleBatch(events []*NetworkEvent) error {
	for _, event := range events {
		seh.HandleEvent(event)
	}
	return nil
}

// ÂÜÖÈÉ®ÊñπÊ≥ï
func (seh *SecurityEventHandler) handleSecurityEvent(event *NetworkEvent) {
	srcIP := ipUint32ToString(event.SrcIP)
	log.Printf("üö® SECURITY ALERT: Suspicious packet from %s (size: %d bytes)", 
		srcIP, event.PacketLen)
	
	if seh.alertCallback != nil {
		seh.alertCallback(event)
	}
}

func (seh *SecurityEventHandler) handleDDoSEvent(event *NetworkEvent) {
	srcIP := ipUint32ToString(event.SrcIP)
	log.Printf("üõ°Ô∏è  DDoS DETECTED: Rate limit exceeded from %s, packet blocked", srcIP)
	
	if seh.alertCallback != nil {
		seh.alertCallback(event)
	}
}

func (seh *SecurityEventHandler) handleAnomalyEvent(event *NetworkEvent) {
	seh.anomalyCount[event.SrcIP]++
	
	if seh.anomalyCount[event.SrcIP] >= seh.anomalyThreshold {
		srcIP := ipUint32ToString(event.SrcIP)
		log.Printf("‚ö†Ô∏è  ANOMALY THRESHOLD EXCEEDED: %s has %d anomalies", 
			srcIP, seh.anomalyCount[event.SrcIP])
		
		if seh.alertCallback != nil {
			seh.alertCallback(event)
		}
		
		// ÈáçÁΩÆËÆ°Êï∞Âô®
		seh.anomalyCount[event.SrcIP] = 0
	}
}

func (seh *SecurityEventHandler) cleanupCounters() {
	for ip := range seh.anomalyCount {
		delete(seh.anomalyCount, ip)
	}
}

// LoadBalancerEventHandler Ë¥üËΩΩÂùáË°°‰∫ã‰ª∂Â§ÑÁêÜÂô®
type LoadBalancerEventHandler struct {
	decisions      map[uint32]uint64 // target_if -> count
	totalDecisions uint64
}

// NewLoadBalancerEventHandler ÂàõÂª∫Ë¥üËΩΩÂùáË°°‰∫ã‰ª∂Â§ÑÁêÜÂô®
func NewLoadBalancerEventHandler() *LoadBalancerEventHandler {
	return &LoadBalancerEventHandler{
		decisions: make(map[uint32]uint64),
	}
}

// HandleEvent Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
func (lbeh *LoadBalancerEventHandler) HandleEvent(event *NetworkEvent) error {
	if event.EventType == EventTypeLoadBalance {
		lbeh.decisions[event.Ifindex]++
		lbeh.totalDecisions++
		
		if lbeh.totalDecisions%1000 == 0 {
			log.Printf("üìä Load Balancer: %d decisions made", lbeh.totalDecisions)
			lbeh.printDistribution()
		}
	}
	return nil
}

// HandleBatch Â§ÑÁêÜÊâπÈáè‰∫ã‰ª∂
func (lbeh *LoadBalancerEventHandler) HandleBatch(events []*NetworkEvent) error {
	for _, event := range events {
		lbeh.HandleEvent(event)
	}
	return nil
}

// GetStats Ëé∑ÂèñË¥üËΩΩÂùáË°°ÁªüËÆ°
func (lbeh *LoadBalancerEventHandler) GetStats() map[uint32]uint64 {
	stats := make(map[uint32]uint64)
	for k, v := range lbeh.decisions {
		stats[k] = v
	}
	return stats
}

func (lbeh *LoadBalancerEventHandler) printDistribution() {
	log.Println("Load Distribution:")
	for target, count := range lbeh.decisions {
		percentage := float64(count) / float64(lbeh.totalDecisions) * 100
		log.Printf("  Target %d: %d packets (%.1f%%)", target, count, percentage)
	}
}

// StatisticsEventHandler ÁªüËÆ°‰∫ã‰ª∂Â§ÑÁêÜÂô®
type StatisticsEventHandler struct {
	packetCount    uint64
	byteCount      uint64
	protocolStats  map[uint8]uint64
	portStats      map[uint16]uint64
	lastReport     time.Time
	reportInterval time.Duration
}

// NewStatisticsEventHandler ÂàõÂª∫ÁªüËÆ°‰∫ã‰ª∂Â§ÑÁêÜÂô®
func NewStatisticsEventHandler() *StatisticsEventHandler {
	return &StatisticsEventHandler{
		protocolStats:  make(map[uint8]uint64),
		portStats:      make(map[uint16]uint64),
		lastReport:     time.Now(),
		reportInterval: 30 * time.Second,
	}
}

// HandleEvent Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
func (seh *StatisticsEventHandler) HandleEvent(event *NetworkEvent) error {
	seh.packetCount++
	seh.byteCount += uint64(event.PacketLen)
	seh.protocolStats[event.Protocol]++
	
	// ÁªüËÆ°ÁõÆÊ†áÁ´ØÂè£
	if event.DstPort != 0 {
		seh.portStats[event.DstPort]++
	}
	
	// ÂÆöÊúüÊä•ÂëäÁªüËÆ°‰ø°ÊÅØ
	if time.Since(seh.lastReport) >= seh.reportInterval {
		seh.reportStatistics()
		seh.lastReport = time.Now()
	}
	
	return nil
}

// HandleBatch Â§ÑÁêÜÊâπÈáè‰∫ã‰ª∂
func (seh *StatisticsEventHandler) HandleBatch(events []*NetworkEvent) error {
	for _, event := range events {
		seh.HandleEvent(event)
	}
	return nil
}

// GetPacketCount Ëé∑ÂèñÊï∞ÊçÆÂåÖËÆ°Êï∞
func (seh *StatisticsEventHandler) GetPacketCount() uint64 {
	return seh.packetCount
}

// GetByteCount Ëé∑ÂèñÂ≠óËäÇËÆ°Êï∞
func (seh *StatisticsEventHandler) GetByteCount() uint64 {
	return seh.byteCount
}

// GetProtocolStats Ëé∑ÂèñÂçèËÆÆÁªüËÆ°
func (seh *StatisticsEventHandler) GetProtocolStats() map[uint8]uint64 {
	stats := make(map[uint8]uint64)
	for k, v := range seh.protocolStats {
		stats[k] = v
	}
	return stats
}

func (seh *StatisticsEventHandler) reportStatistics() {
	log.Printf("üìà Statistics Report:")
	log.Printf("  Total Packets: %d", seh.packetCount)
	log.Printf("  Total Bytes: %s", formatBytes(seh.byteCount))
	
	// ÂçèËÆÆÂàÜÂ∏É
	log.Printf("  Protocol Distribution:")
	for proto, count := range seh.protocolStats {
		percentage := float64(count) / float64(seh.packetCount) * 100
		log.Printf("    %s: %d (%.1f%%)", getProtocolName(proto), count, percentage)
	}
}

// CompositeEventHandler Â§çÂêà‰∫ã‰ª∂Â§ÑÁêÜÂô®ÔºåÂèØÁªÑÂêàÂ§ö‰∏™Â§ÑÁêÜÂô®
type CompositeEventHandler struct {
	handlers []EventHandler
}

// NewCompositeEventHandler ÂàõÂª∫Â§çÂêà‰∫ã‰ª∂Â§ÑÁêÜÂô®
func NewCompositeEventHandler() *CompositeEventHandler {
	return &CompositeEventHandler{
		handlers: make([]EventHandler, 0),
	}
}

// AddHandler Ê∑ªÂä†‰∫ã‰ª∂Â§ÑÁêÜÂô®
func (ceh *CompositeEventHandler) AddHandler(handler EventHandler) {
	ceh.handlers = append(ceh.handlers, handler)
}

// HandleEvent Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
func (ceh *CompositeEventHandler) HandleEvent(event *NetworkEvent) error {
	for _, handler := range ceh.handlers {
		if err := handler.HandleEvent(event); err != nil {
			log.Printf("Handler error: %v", err)
		}
	}
	return nil
}

// HandleBatch Â§ÑÁêÜÊâπÈáè‰∫ã‰ª∂
func (ceh *CompositeEventHandler) HandleBatch(events []*NetworkEvent) error {
	for _, handler := range ceh.handlers {
		if err := handler.HandleBatch(events); err != nil {
			log.Printf("Batch handler error: %v", err)
		}
	}
	return nil
}

// ËæÖÂä©ÂáΩÊï∞
func ipUint32ToString(ip uint32) string {
	return fmt.Sprintf("%d.%d.%d.%d",
		ip&0xFF, (ip>>8)&0xFF, (ip>>16)&0xFF, ip>>24)
}

func ipStringToUint32(ipStr string) (uint32, error) {
	ip := net.ParseIP(ipStr)
	if ip == nil {
		return 0, fmt.Errorf("invalid IP address")
	}
	ip = ip.To4()
	if ip == nil {
		return 0, fmt.Errorf("not an IPv4 address")
	}
	return uint32(ip[0]) | uint32(ip[1])<<8 | uint32(ip[2])<<16 | uint32(ip[3])<<24, nil
}

// SecurityEventHandler ÂÆâÂÖ®‰∫ã‰ª∂Â§ÑÁêÜÂô®
type SecurityEventHandler struct {
	alertCallback    func(event *NetworkEvent)
	anomalyThreshold int
	anomalyCount     map[uint32]int // IP -> count
	lastCleanup      time.Time
}

// NewSecurityEventHandler ÂàõÂª∫ÂÆâÂÖ®‰∫ã‰ª∂Â§ÑÁêÜÂô®
func NewSecurityEventHandler() *SecurityEventHandler {
	return &SecurityEventHandler{
		anomalyThreshold: 10, // 10Ê¨°ÂºÇÂ∏∏ÂêéËß¶ÂèëÂëäË≠¶
		anomalyCount:     make(map[uint32]int),
		lastCleanup:      time.Now(),
	}
}

// SetAlertCallback ËÆæÁΩÆÂëäË≠¶ÂõûË∞ÉÂáΩÊï∞
func (seh *SecurityEventHandler) SetAlertCallback(callback func(event *NetworkEvent)) {
	seh.alertCallback = callback
}

// HandleEvent Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
func (seh *SecurityEventHandler) HandleEvent(event *NetworkEvent) error {
	switch event.EventType {
	case EventTypeSecurity:
		seh.handleSecurityEvent(event)
	case EventTypeDDoS:
		seh.handleDDoSEvent(event)
	case EventTypeAnomaly:
		seh.handleAnomalyEvent(event)
	}

	// ÂÆöÊúüÊ∏ÖÁêÜËÆ°Êï∞Âô®
	if time.Since(seh.lastCleanup) > 5*time.Minute {
		seh.cleanupCounters()
		seh.lastCleanup = time.Now()
	}

	return nil
}

// HandleBatch Â§ÑÁêÜÊâπÈáè‰∫ã‰ª∂
func (seh *SecurityEventHandler) HandleBatch(events []*NetworkEvent) error {
	for _, event := range events {
		seh.HandleEvent(event)
	}
	return nil
}

// handleSecurityEvent Â§ÑÁêÜÂÆâÂÖ®‰∫ã‰ª∂
func (seh *SecurityEventHandler) handleSecurityEvent(event *NetworkEvent) {
	srcIP := uint32ToIPString(event.SrcIP)
	log.Printf("üö® SECURITY ALERT: Suspicious packet from %s (size: %d bytes)",
		srcIP, event.PacketLen)

	if seh.alertCallback != nil {
		seh.alertCallback(event)
	}
}

// handleDDoSEvent Â§ÑÁêÜDDoS‰∫ã‰ª∂
func (seh *SecurityEventHandler) handleDDoSEvent(event *NetworkEvent) {
	srcIP := uint32ToIPString(event.SrcIP)
	log.Printf("üõ°Ô∏è  DDoS DETECTED: Rate limit exceeded from %s, packet blocked", srcIP)

	if seh.alertCallback != nil {
		seh.alertCallback(event)
	}
}

// handleAnomalyEvent Â§ÑÁêÜÂºÇÂ∏∏‰∫ã‰ª∂
func (seh *SecurityEventHandler) handleAnomalyEvent(event *NetworkEvent) {
	seh.anomalyCount[event.SrcIP]++

	if seh.anomalyCount[event.SrcIP] >= seh.anomalyThreshold {
		srcIP := uint32ToIPString(event.SrcIP)
		log.Printf("‚ö†Ô∏è  ANOMALY THRESHOLD EXCEEDED: %s has %d anomalies",
			srcIP, seh.anomalyCount[event.SrcIP])

		if seh.alertCallback != nil {
			seh.alertCallback(event)
		}

		// ÈáçÁΩÆËÆ°Êï∞Âô®
		seh.anomalyCount[event.SrcIP] = 0
	}
}

// cleanupCounters Ê∏ÖÁêÜËøáÊúüÁöÑËÆ°Êï∞Âô®
func (seh *SecurityEventHandler) cleanupCounters() {
	for ip := range seh.anomalyCount {
		delete(seh.anomalyCount, ip)
	}
}

// LoadBalancerEventHandler Ë¥üËΩΩÂùáË°°‰∫ã‰ª∂Â§ÑÁêÜÂô®
type LoadBalancerEventHandler struct {
	decisions      map[uint32]uint64 // target_if -> count
	totalDecisions uint64
}

// NewLoadBalancerEventHandler ÂàõÂª∫Ë¥üËΩΩÂùáË°°‰∫ã‰ª∂Â§ÑÁêÜÂô®
func NewLoadBalancerEventHandler() *LoadBalancerEventHandler {
	return &LoadBalancerEventHandler{
		decisions: make(map[uint32]uint64),
	}
}

// HandleEvent Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
func (lbeh *LoadBalancerEventHandler) HandleEvent(event *NetworkEvent) error {
	if event.EventType == EventTypeLoadBalance {
		lbeh.decisions[event.Ifindex]++
		lbeh.totalDecisions++

		if lbeh.totalDecisions%1000 == 0 {
			log.Printf("üìä Load Balancer: %d decisions made", lbeh.totalDecisions)
			lbeh.printDistribution()
		}
	}
	return nil
}

// HandleBatch Â§ÑÁêÜÊâπÈáè‰∫ã‰ª∂
func (lbeh *LoadBalancerEventHandler) HandleBatch(events []*NetworkEvent) error {
	for _, event := range events {
		lbeh.HandleEvent(event)
	}
	return nil
}

// printDistribution ÊâìÂç∞Ë¥üËΩΩÂàÜÂ∏É
func (lbeh *LoadBalancerEventHandler) printDistribution() {
	log.Println("Load Distribution:")
	for target, count := range lbeh.decisions {
		percentage := float64(count) / float64(lbeh.totalDecisions) * 100
		log.Printf("  Target %d: %d packets (%.1f%%)", target, count, percentage)
	}
}

// GetStats Ëé∑ÂèñË¥üËΩΩÂùáË°°ÁªüËÆ°
func (lbeh *LoadBalancerEventHandler) GetStats() map[uint32]uint64 {
	stats := make(map[uint32]uint64)
	for k, v := range lbeh.decisions {
		stats[k] = v
	}
	return stats
}

// StatisticsEventHandler ÁªüËÆ°‰∫ã‰ª∂Â§ÑÁêÜÂô®
type StatisticsEventHandler struct {
	packetCount    uint64
	byteCount      uint64
	protocolStats  map[uint8]uint64
	portStats      map[uint16]uint64
	lastReport     time.Time
	reportInterval time.Duration
}

// NewStatisticsEventHandler ÂàõÂª∫ÁªüËÆ°‰∫ã‰ª∂Â§ÑÁêÜÂô®
func NewStatisticsEventHandler() *StatisticsEventHandler {
	return &StatisticsEventHandler{
		protocolStats:  make(map[uint8]uint64),
		portStats:      make(map[uint16]uint64),
		lastReport:     time.Now(),
		reportInterval: 30 * time.Second,
	}
}

// HandleEvent Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
func (seh *StatisticsEventHandler) HandleEvent(event *NetworkEvent) error {
	seh.packetCount++
	seh.byteCount += uint64(event.PacketLen)
	seh.protocolStats[event.Protocol]++

	// ÁªüËÆ°ÁõÆÊ†áÁ´ØÂè£
	if event.DstPort != 0 {
		seh.portStats[event.DstPort]++
	}

	// ÂÆöÊúüÊä•ÂëäÁªüËÆ°‰ø°ÊÅØ
	if time.Since(seh.lastReport) >= seh.reportInterval {
		seh.reportStatistics()
		seh.lastReport = time.Now()
	}

	return nil
}

// HandleBatch Â§ÑÁêÜÊâπÈáè‰∫ã‰ª∂
func (seh *StatisticsEventHandler) HandleBatch(events []*NetworkEvent) error {
	for _, event := range events {
		seh.HandleEvent(event)
	}
	return nil
}

// reportStatistics Êä•ÂëäÁªüËÆ°‰ø°ÊÅØ
func (seh *StatisticsEventHandler) reportStatistics() {
	log.Printf("üìà Statistics Report:")
	log.Printf("  Total Packets: %d", seh.packetCount)
	log.Printf("  Total Bytes: %s", formatBytes(seh.byteCount))

	// ÂçèËÆÆÂàÜÂ∏É
	log.Printf("  Protocol Distribution:")
	for proto, count := range seh.protocolStats {
		percentage := float64(count) / float64(seh.packetCount) * 100
		log.Printf("    %s: %d (%.1f%%)", getProtocolName(proto), count, percentage)
	}

	// ÁÉ≠Èó®Á´ØÂè£
	log.Printf("  Top Destination Ports:")
	type portStat struct {
		port  uint16
		count uint64
	}
	var topPorts []portStat
	for port, count := range seh.portStats {
		topPorts = append(topPorts, portStat{port, count})
	}

	// ÁÆÄÂçïÊéíÂ∫èÔºàÂèñÂâç5‰∏™Ôºâ
	for i := 0; i < len(topPorts) && i < 5; i++ {
		for j := i + 1; j < len(topPorts); j++ {
			if topPorts[j].count > topPorts[i].count {
				topPorts[i], topPorts[j] = topPorts[j], topPorts[i]
			}
		}
		percentage := float64(topPorts[i].count) / float64(seh.packetCount) * 100
		log.Printf("    Port %d: %d (%.1f%%)", topPorts[i].port, topPorts[i].count, percentage)
	}
}

// GetPacketCount Ëé∑ÂèñÊï∞ÊçÆÂåÖËÆ°Êï∞
func (seh *StatisticsEventHandler) GetPacketCount() uint64 {
	return seh.packetCount
}

// GetByteCount Ëé∑ÂèñÂ≠óËäÇËÆ°Êï∞
func (seh *StatisticsEventHandler) GetByteCount() uint64 {
	return seh.byteCount
}

// GetProtocolStats Ëé∑ÂèñÂçèËÆÆÁªüËÆ°
func (seh *StatisticsEventHandler) GetProtocolStats() map[uint8]uint64 {
	stats := make(map[uint8]uint64)
	for k, v := range seh.protocolStats {
		stats[k] = v
	}
	return stats
}

// CompositeEventHandler Â§çÂêà‰∫ã‰ª∂Â§ÑÁêÜÂô®ÔºåÂèØÁªÑÂêàÂ§ö‰∏™Â§ÑÁêÜÂô®
type CompositeEventHandler struct {
	handlers []EventHandler
}

// NewCompositeEventHandler ÂàõÂª∫Â§çÂêà‰∫ã‰ª∂Â§ÑÁêÜÂô®
func NewCompositeEventHandler() *CompositeEventHandler {
	return &CompositeEventHandler{
		handlers: make([]EventHandler, 0),
	}
}

// AddHandler Ê∑ªÂä†‰∫ã‰ª∂Â§ÑÁêÜÂô®
func (ceh *CompositeEventHandler) AddHandler(handler EventHandler) {
	ceh.handlers = append(ceh.handlers, handler)
}

// HandleEvent Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
func (ceh *CompositeEventHandler) HandleEvent(event *NetworkEvent) error {
	for _, handler := range ceh.handlers {
		if err := handler.HandleEvent(event); err != nil {
			log.Printf("Handler error: %v", err)
		}
	}
	return nil
}

// HandleBatch Â§ÑÁêÜÊâπÈáè‰∫ã‰ª∂
func (ceh *CompositeEventHandler) HandleBatch(events []*NetworkEvent) error {
	for _, handler := range ceh.handlers {
		if err := handler.HandleBatch(events); err != nil {
			log.Printf("Batch handler error: %v", err)
		}
	}
	return nil
}
